---
title: "Retrospectives"
description: "Considerations of how your context impacts your ability to gain value from retrospectives"
date: 2023-05-23T00:00:00+05:00
draft: false
weight: 30
---

### What is a retrospective?
A retrospective is a meeting to review your software development processes and practices and consider opportunities where you can make improvements.  Retrospectives are very common in agile approaches to software development and is a core step in the Scrum framework.

Opinions about the value of retrospectives vary widely with some people claiming adamantly that they are a necessity and others claiming they are usually a waste of time.  If you have participated in a lot of retrospectives you have probably found some to be valuable, and others to be a waste of time.

Of course, as this site claims, the value of your retrospective is probably greatly dependent upon your context.  

Most teams should expect that the value gained from retrospectives follows the law of diminishing returns.  That means that you may gain a lot of value from retrospectives in the beginning, but as your team makes changes based on the outcomes of those retrospectives, the team finds fewer and fewer obstacles that are worth trying to remove.  Teams that feel retrospectives are necessary may resort to trying to make retrospectives more fun once they no longer seem productive.  However, sometimes games can help break the ice when teams are new and build trust in order to facilitate communication, so using games during retrospectives is not always a sign of a poor practice.  Some retrospectives continue when they rarely provide value because a project leader or scrum master believe the meeting helps justify that they are bringing value to the team.
Another criticism of retrospectives is that they often focus on process improvements, when the process is already working fairly well and focusing improvments on other elements of the software development context would provide more value than focusing on improvements in the software development process itself.  This problem manifests from two sources.  In some cases, the retrospective facilitator steers away from improvements in areas such as software architecture or coding tools because the facilitator does not have deep knowledge of those things and feels they could add little value to decisions made.  In other cases, the team has failed to recognize that continual process improvement is detrimental to most software development teams.  Unlike manufacturing processes, where the desire is for every output to be the same, thus you want to improve your process until it is perfect at producing that output; in software development, the desire is for every output to be different; and therefore a process that was optimal for producing the previous feature is probably not optimal for producing the next feature.

Despite all of those criticisms, almost every team and person probably benefits from some retrospectives.  While you are finding them valuable, certainaly keep doing them.  They can be very valuable and often require several such meetings for team members to learn to trust each other and speak openly about issues that are hindering their process.  As their value decreases, or as you find there are more valuable things to do with every team members time, hold fewer such meetings.

### How does your context affect the success you will have with retrospectives?
###### *1. How does the *[Organizational Structure](/docs/elements/orgstructure/)* in your context impact the probability that you will have success with *retrospectives*?
Retrospectives usually provide the most value when you discover changes that will last a long time that can be made to how a team operates.  When team members change frequently, the need for retrospectives can increase, and the results of each retrospective may provide less value because those learning the changes move on and changes become more difficult to implement.  Another important aspect of successful retrospectives is that team members feel ownership of the software they are producing and the process by which they are produced.  When team members change frequently that is harder to achieve.  Therefore some organizations with matrix structures in which team members change frequently adopt the same process across all projects and teams, which tends to cause each team to operate less effectively than they might and tends to discourage team members from attempting to offer ideas for improvements they know won't be implemented.  
###### *2. How does the *[Development Team Culture](/docs/elements/devculture/)* in your context impact the probability that you will have success with *retrospectives*?
Cultures that suppress change, punish those that make mistakes, and lack trust between team members are unlikely to benefit from retrospectives until cultural improvements are made.  Holding retrospectives when the organization has a history of suppressing change and new ideas is difficult, and change suggestions from retrospectives need to be provided serious consideration of the change ideas will quickly cease to be provided.  A poor team culture is probably the biggest impediment to getting some value out of retrospectives.  Team members need to learn that their ideaswill get consideration and that their product, customers, and co-workers are worth investing energy in before they will start to become motivated to make improvements and believe improvements are possible?
###### 3. How does the *[Hiring Process](/docs/elements/hiringprocess/)* in your context impact the probability that you will have success with *retrospectives*?
Your organization's hiring process probably has little impact on your team's ability to gain value from retrospectives.
###### *4. How does the *[Team Composition](/docs/elements/teamcomposition/)* in your context impact the probability that you will have success with *retrospectives*?
Juniors team members ofter have a lot more to learn, especially by pondering and questioning how things are currently done.  But retrospectives may be more valuable when there are senior team members because they have more experience to draw upon and to see the problems.  They also probably have more ideas about how to remedy some of the problems.  Mature teams may have near optimal processes and process-focused retros become less valuable.  Retrospectives are also more difficult for solo developers.  Another aspect of team composition that may be important is the number of disgruntled team members that no longer believe things can get better relative to the number of team members that don't hold that belief, perhaps because they are new or perhaps they are just naturally more optimistic.  If your team is full of doubters, it might help to bring in some optimistic people to start suggesting changes.
###### 5. How does the *[Training Provided on Code](/docs/elements/trainingoncoding/)* in your context impact the probability that you will have success with *retrospectives*?
The training provided on code probably has little impact on the value retrospectives may bring to your team.
###### 6. How does the *[Training Provided on 'Our Ways of Doing Things'](/docs/elements/trainingonourways/)* in your context impact the probability that you will have success with *retrospectives*?
The training your team provides on how things are done likely help new team members understand what is expected during retrospectives, especially if retrospectives are part of how your things are done.  For teams that don't provide such training, a side-benefit of retrospectives might be more that the discussion of how yoru team does things helps new team members understand why things are currently done as they are.
###### 7. How does the *[Environment](/docs/elements/environment/)* in your context impact the probability that you will have success with *retrospectives*?
The environment probably has little impact on the value retrospectives may bring to your team, though attempts to improve a poor environment are likely to be suggested during retrospectives when such is the case.
###### 8. How does the *[Project Selection](/docs/elements/projectselection/)* in your context impact the probability that you will have success with *retrospectives*?
The way in which projects are selected probably has no impact on the value retrospectives may bring to your team, but retrospectives might suggest improvements to how projects are selected.


###### *9. How does the *[Solution Purpose](/docs/elements/solutionpurpose/)* in your context impact the probability that you will have success with *retrospectives*?
Reminder, TDD is not about producing tests.  Some solutions don't need or even desire tests.  Prototypes, demo apps, technical proofs of concept, integration scripts, run once projects,  and solutions that are temporary often don't merit the time required to produce tests to go with them.  Getting a solution deployed quickly may be more important than having any tests for the solution.  Solutions where the damage caused by errors and the ease of fixing errors is minimal benefit less from tests.  Yet in some of these cases, the TDD process may help produce the solution even if the tests are discarded.  If quality is not important, and the solution has a short lifetime, TDD and tests probably provide less value.
###### 10. How do the *[Application Architecture Priorities](/docs/elements/apparchpriorities/)* in your context impact the probability that you will have success with *retrospectives*?
The benefits TDD may provide probably do not vary much even if your application places strong demands on performance, or scalability, or back-compatibility, ore most other architecture priorities.  Tests can make a very big difference, but the TDD process itself probably does not.  One exception to this may be if your architecture needs a robust API, because APIs consumed by others usually demand higher reliability, predictability, along with simplicity.
###### 11. How do the *[Security Demands](/docs/elements/securitydemands/)* in your context impact the probability that you will have success with *retrospectives*?
Like other architecture priorities, the security demands of your solution have little impact on your team's ability to use TDD, and TDD doesn't necessarily contribute to the security of your code.
###### *12. How do the *[Requirements, Features, and Priorities](/docs/elements/rqmtsandfeatures/)* in your context impact the probability that you will have success with *retrospectives*?
In order to write tests you need to know what results to expect.  You need clarity in your requirements.  Without that, you may spend a lot of time rewriting tests and software as you repeatedly discover that the feature you delivered is not what the users of the feature wanted.  This is not a problem unique with TDD, but it does mean that you are more likely to throw away a lot of tests, and consider the time you spent writing them to be wasted, when you are unable to obtain clear requirements when needed.  The waste is not only unproductive, but can also be demoralizing to team members.  From the opposite perspective, using TDD can help you discover more quickly when your requirements are not complete.  So if you are able to get clarification easily, TDD can be very helpful to getting code right the first time.
###### 13. How do the *[Regulations](/docs/elements/regulations/)* in your context impact the probability that you will have success with *retrospectives*?
The regulations your organization must comply with probably have no impact on your team's ability to use TDD.
###### 14. How does *[Who Decides What To Do](/docs/elements/whodecides/)* in your context impact the probability that you will have success with *retrospectives*?
Who decides what to do next on your teams probably has little impact on your team's ability to use TDD.
###### 15. How does *[Project Management](/docs/elements/projectmanagement/)* in your context impact the probability that you will have success with *retrospectives*?
How your team manages projects and tasks probably has little impact on your team's ability to use TDD.
###### 16. How do the *[Quality Processes](/docs/elements/qualityprocesses/)* in your context impact the probability that you will have success with *retrospectives*?
The processes you use to insure quality in your application probably have little impact on your team's ability to use TDD, but TDD may produce higher quality code which simplifies quality assurance processes.  Tests themselves are a quality assurance practice.  Developers write their own tests on some teams, but QA employees write tests for other teams.  TDD tests are almost always written by developers as part of the development process, but those tests can be included with the tests created by the QA team.
###### 17. How does the *[Architecture Forecasting](/docs/elements/architectureforecasting/)* in your context impact the probability that you will have success with *retrospectives*?
The plans you have for evolving the architecture of your application probably have no impact on your team's ability to use TDD.
###### 18. How do your *[DevOps](/docs/elements/devops/)* in your context impact the probability that you will have success with *retrospectives*?
Your DevOps processes probably don't impact your ability to use TDD, but they may affect your ability to run the tests, particularly if all tests are ran and the test suite is extremely large.
###### *19. How does the *[Architecture](/docs/elements/architecture/)* in your context impact the probability that you will have success with *retrospectives*?
The architecture of your application has a big impact on your ability to use TDD.  As mentioned previously, some architectures and partial architectures using low-code solutions offer no tools to write tests.  Microservices may be so small that the pieces of code don't have any logic that needs tests, yet the overall solution does, in which case those would be integration tests, not TDD generated unit tests.  APIs, back-end solutions, solutions without user-interfaces are architectures more likely to benefit from TDD.  Integration scripts and run once projects rarely benefit from TDD.  User Interfaces for web sites, web applications, and phone apps vary in their benefits derived from TDD based on their tooling.
###### *20. How does the *[Code](/docs/elements/code/)* in your context impact the probability that you will have success with *retrospectives*?
The specific languages and tools used to write code determine if using TDD is even an option for consideration.  For many older development technologies like Visual Basic 6 or Paradox or FoxPro, unit tests are nearly impossible.  New technologies like low-code IDEs rarely, perhaps never, offer a way to write tests.  If you want to use TDD you certainly need coding languages like C#, Java, Javascript, and many others that support it; along with IDEs that can facilitate the process.
###### *21.How does the *[Code Quality](/docs/elements/codequality/)* in your context impact the probability that you will have success with *retrospectives*?
Many developers find themselves unable to get started using TDD because they work on an existing code base that lacks tests, and also because that codebase is not well written and every test to cover the current code would be an integration test because each function in the code does too much.  For poor codebases, much refactoring is probably needed before you can begin making changes to it using TDD as you modify existing features and add new ones.  TDD is much easier to begin with when starting development on a new code base.
###### 22. How does the *[Application Quality](/docs/elements/appquality/)* in your context impact the probability that you will have success with *retrospectives*?
The current quality of your application probably has no impact on your team's ability to use TDD.
###### 23. How does the *[Deployment Environment](/docs/elements/deployenvironment/)* in your context impact the probability that you will have success with *retrospectives*?
The environment into which your software is deployed may have some impact on your ability to use TDD.  This is primarily because the tooling for some types of solutions and languages is not as easy to write tests with as others.  It is usually easiest to write tests for solutions deployed as back-end processes on servers, and a little more difficult to write tests for solutions deployed in browsers.  Some low-code and no-code platform don't provide any ability to write tests.
###### 24. How does the *[Product Training](/docs/elements/producttraining/)* in your context impact the probability that you will have success with *retrospectives*?
How your team trains people using your solution probably has no impact on your team's ability to use TDD.
###### 25. How does the *[Support](/docs/elements/support/)* in your context impact the probability that you will have success with *retrospectives*?
How your team supports people using your solution probably has no impact on your team's ability to use TDD.
